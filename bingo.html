<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>ğŸ§§ ç›§æ°é›†åœ˜é¦¬ä¸Šæœ‰éŒ¢ è³“æœå¤§æ¨‚é€</title>

<!-- Firebase SDK -->
<script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>

<style>
@import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700;900&family=ZCOOL+KuaiLe&display=swap');

:root {
  --red: #C41E1E;
  --red-dark: #7A0000;
  --red-deep: #520000;
  --gold: #F0C040;
  --gold-bright: #FFD700;
  --gold-dim: #B8860B;
  --cream: #FFF8E8;
  --cream-dark: #F5E6C8;
  --ink: #1A0505;
  --glass: rgba(0,0,0,0.25);
}

* { box-sizing: border-box; margin: 0; padding: 0; }
html, body { height: 100%; overflow-x: hidden; }
body {
  font-family: 'Noto Sans TC', sans-serif;
  background: var(--red-deep);
  color: var(--cream);
  -webkit-tap-highlight-color: transparent;
}

/* BG */
.bg {
  position: fixed; inset: 0; z-index: 0;
  background:
    radial-gradient(ellipse at 30% 20%, rgba(240,192,64,0.08) 0%, transparent 50%),
    radial-gradient(ellipse at 70% 80%, rgba(196,30,30,0.15) 0%, transparent 40%),
    linear-gradient(175deg, #520000 0%, #7A0000 35%, #520000 70%, #3A0000 100%);
}
.particles { position: fixed; inset: 0; z-index: 0; pointer-events: none; overflow: hidden; }
.particle {
  position: absolute; opacity: 0.2;
  animation: drift linear infinite;
}
@keyframes drift {
  0% { transform: translateY(105vh) rotate(0deg); opacity: 0; }
  8% { opacity: 0.25; }
  85% { opacity: 0.25; }
  100% { transform: translateY(-5vh) rotate(30deg) scale(0.7); opacity: 0; }
}

/* Screens */
.screen { display: none; position: relative; z-index: 1; min-height: 100vh; }
.screen.active { display: flex; flex-direction: column; }

/* =============== LOGIN =============== */
#loginScreen { align-items: center; justify-content: center; padding: 30px 20px; }

.login-card {
  background: linear-gradient(160deg, rgba(255,248,232,0.96), rgba(245,230,200,0.93));
  border: 3px solid var(--gold);
  border-radius: 24px;
  padding: 36px 28px;
  max-width: 400px;
  width: 100%;
  box-shadow: 0 8px 60px rgba(0,0,0,0.4), 0 0 80px rgba(240,192,64,0.1);
  color: var(--ink);
  animation: cardUp 0.7s cubic-bezier(0.175,0.885,0.32,1.275);
}
@keyframes cardUp { from { opacity:0; transform: translateY(40px) scale(0.9); } to { opacity:1; transform: translateY(0) scale(1); } }

.login-header { font-size: 2.5rem; text-align: center; margin-bottom: 4px; }
.login-title { font-family: 'ZCOOL KuaiLe', cursive; font-size: 2rem; color: var(--red); text-align: center; }
.login-sub { font-size: 0.82rem; color: var(--red-dark); opacity: 0.65; text-align: center; margin-bottom: 24px; }

.input-group { margin-bottom: 14px; text-align: left; }
.input-group label { display: block; font-size: 0.78rem; font-weight: 700; color: var(--red-dark); margin-bottom: 5px; opacity: 0.8; }
.input-group input {
  width: 100%; padding: 13px 15px;
  border: 2px solid rgba(196,30,30,0.18);
  border-radius: 13px;
  font-family: 'Noto Sans TC', sans-serif; font-size: 1.05rem;
  background: rgba(255,255,255,0.7); color: var(--ink); outline: none;
  transition: border-color 0.2s;
}
.input-group input:focus { border-color: var(--gold); }
.input-group input::placeholder { color: #bbb; }

.player-count-group {
  display: flex; align-items: center; gap: 10px; margin-bottom: 18px;
}
.player-count-group label { font-size: 0.78rem; font-weight: 700; color: var(--red-dark); opacity: 0.8; white-space: nowrap; }
.player-count-group select {
  flex: 1; padding: 12px 14px;
  border: 2px solid rgba(196,30,30,0.18); border-radius: 13px;
  font-family: 'Noto Sans TC', sans-serif; font-size: 1rem;
  background: rgba(255,255,255,0.7); color: var(--ink); outline: none;
}

.login-btn {
  width: 100%; padding: 15px;
  background: linear-gradient(135deg, var(--red) 0%, var(--red-dark) 100%);
  color: var(--gold-bright); border: 2px solid var(--gold);
  border-radius: 16px;
  font-family: 'ZCOOL KuaiLe', cursive; font-size: 1.25rem;
  cursor: pointer; transition: all 0.2s; letter-spacing: 2px;
  box-shadow: 0 4px 20px rgba(122,0,0,0.3); margin-top: 6px;
}
.login-btn:hover { transform: translateY(-2px); }
.login-btn:active { transform: scale(0.97); }
.login-btn.secondary {
  background: rgba(255,255,255,0.6);
  color: var(--red-dark);
  font-size: 1rem;
  padding: 12px;
  box-shadow: 0 2px 12px rgba(122,0,0,0.15);
}

.mode-switch {
  display: flex; gap: 10px; margin: 20px 0 16px;
}
.mode-btn {
  flex: 1; padding: 10px;
  background: rgba(255,255,255,0.5); color: var(--red-dark);
  border: 2px solid rgba(196,30,30,0.15); border-radius: 12px;
  font-family: 'Noto Sans TC', sans-serif; font-size: 0.9rem; font-weight: 700;
  cursor: pointer; transition: all 0.2s;
}
.mode-btn.active {
  background: linear-gradient(135deg, var(--red) 0%, var(--red-dark) 100%);
  color: var(--gold-bright); border-color: var(--gold);
}
.room-code-display {
  background: rgba(240,192,64,0.15); border: 2px solid var(--gold);
  border-radius: 12px; padding: 12px; margin: 16px 0;
  text-align: center;
}
.room-code-display .label { font-size: 0.7rem; color: var(--red-dark); opacity: 0.7; margin-bottom: 4px; }
.room-code-display .code { font-family: 'ZCOOL KuaiLe', cursive; font-size: 1.8rem; color: var(--red); letter-spacing: 4px; }
.sync-badge {
  display: inline-block; background: rgba(76,175,80,0.15);
  border: 1.5px solid #4CAF50; border-radius: 20px;
  padding: 4px 12px; font-size: 0.7rem; color: #2E7D32; font-weight: 700;
  margin-left: 6px;
}

/* =============== GAME =============== */
#gameScreen { padding: 0 0 30px; }

/* Top bar */
.top-bar {
  background: linear-gradient(180deg, rgba(0,0,0,0.45) 0%, transparent 100%);
  padding: 12px 16px 16px;
  display: flex; align-items: center; justify-content: space-between;
  position: sticky; top: 0; z-index: 10;
  backdrop-filter: blur(12px);
}
.top-title { font-family: 'ZCOOL KuaiLe', cursive; font-size: 1.25rem; color: var(--gold); }
.top-info { font-size: 0.7rem; color: var(--gold-dim); opacity: 0.7; }
.top-right { display: flex; gap: 8px; align-items: center; }
.btn-sm {
  padding: 6px 14px; border: 1.5px solid rgba(240,192,64,0.4);
  border-radius: 20px; background: var(--glass);
  color: var(--gold); font-family: 'Noto Sans TC', sans-serif;
  font-size: 0.78rem; font-weight: 700; cursor: pointer; transition: all 0.15s;
}
.btn-sm:hover { background: rgba(240,192,64,0.15); }

/* Player tabs */
.player-bar { padding: 0 16px; margin-bottom: 12px; }
.player-bar-label { font-size: 0.68rem; color: var(--gold-dim); font-weight: 700; letter-spacing: 1px; margin-bottom: 6px; }
.player-tabs { display: flex; gap: 6px; flex-wrap: wrap; }
.ptab {
  padding: 7px 14px; border-radius: 20px;
  border: 1.5px solid rgba(240,192,64,0.25);
  background: var(--glass); color: var(--cream);
  font-family: 'Noto Sans TC', sans-serif; font-size: 0.82rem; font-weight: 700;
  cursor: pointer; transition: all 0.15s;
  display: flex; align-items: center; gap: 5px;
}
.ptab.active { background: rgba(240,192,64,0.15); border-color: var(--gold); color: var(--gold); }
.ptab .dot { width: 7px; height: 7px; background: #4CAF50; border-radius: 50%; box-shadow: 0 0 6px #4CAF50; }
.ptab .bingo-flag { background: var(--gold); color: var(--red-dark); font-size: 0.55rem; font-weight: 900; padding: 1px 6px; border-radius: 8px; }

/* Called board */
.called-section { padding: 0 16px; margin-bottom: 14px; }
.called-board {
  background: linear-gradient(160deg, rgba(0,0,0,0.35), rgba(0,0,0,0.5));
  border: 1.5px solid rgba(240,192,64,0.2);
  border-radius: 18px; padding: 14px; backdrop-filter: blur(8px);
}
.called-board-title { font-size: 0.68rem; color: var(--gold-dim); font-weight: 700; letter-spacing: 1px; text-align: center; margin-bottom: 10px; }

.called-list {
  display: flex; flex-direction: column; gap: 5px;
  max-height: 200px; overflow-y: auto; scroll-behavior: smooth;
}
.called-list::-webkit-scrollbar { width: 4px; }
.called-list::-webkit-scrollbar-thumb { background: rgba(240,192,64,0.3); border-radius: 4px; }

.called-row {
  display: flex; align-items: center; gap: 8px;
  padding: 7px 10px; background: rgba(255,255,255,0.04); border-radius: 10px;
  animation: rowIn 0.3s ease-out;
}
@keyframes rowIn { from { opacity:0; transform: translateX(-12px); } to { opacity:1; transform: translateX(0); } }
.called-row.latest { background: rgba(240,192,64,0.1); border: 1px solid rgba(240,192,64,0.25); }
.c-round { font-size: 0.63rem; color: var(--gold-dim); min-width: 26px; font-weight: 700; }
.c-icon { font-size: 1.3rem; }
.c-name { font-size: 0.82rem; color: var(--cream); font-weight: 700; flex: 1; }
.c-who { font-size: 0.7rem; color: var(--gold-dim); }

.empty-hint { text-align: center; padding: 18px; color: var(--gold-dim); font-size: 0.82rem; opacity: 0.5; }

/* Action */
.action-area { padding: 0 16px; margin-bottom: 16px; }
.turn-info {
  text-align: center; font-size: 0.85rem; color: var(--gold);
  margin-bottom: 10px; font-weight: 700;
  padding: 10px; background: rgba(240,192,64,0.1); border-radius: 12px;
  display: flex; align-items: center; justify-content: center; gap: 10px;
}
.turn-info.my-turn {
  background: rgba(76,175,80,0.15);
  border: 2px solid #4CAF50;
  animation: pulseTurn 1.5s ease-in-out infinite;
}
@keyframes pulseTurn { 0%,100%{transform:scale(1)} 50%{transform:scale(1.02)} }
.turn-timer {
  display: inline-flex; align-items: center; justify-content: center;
  min-width: 36px; height: 36px;
  background: rgba(0,0,0,0.3); border-radius: 50%;
  font-family: 'ZCOOL KuaiLe', cursive; font-size: 1.1rem;
  color: var(--gold); flex-shrink: 0;
}
.turn-timer.warning { color: #FF5722; animation: pulse 1s infinite; }
@keyframes pulse { 0%,100%{opacity:1} 50%{opacity:0.4} }

/* Item Selection Grid */
.item-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
  gap: 8px;
  max-height: 280px;
  overflow-y: auto;
  padding: 8px;
  background: rgba(0,0,0,0.2);
  border-radius: 16px;
}
.item-grid::-webkit-scrollbar { width: 6px; }
.item-grid::-webkit-scrollbar-thumb { background: rgba(240,192,64,0.4); border-radius: 6px; }

.item-choice {
  aspect-ratio: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background: rgba(255,248,232,0.9);
  border: 2px solid rgba(196,30,30,0.15);
  border-radius: 12px;
  cursor: pointer;
  transition: all 0.2s;
  padding: 6px;
}
.item-choice:hover {
  transform: translateY(-3px);
  border-color: var(--gold);
  box-shadow: 0 4px 12px rgba(240,192,64,0.3);
}
.item-choice:active { transform: scale(0.95); }
.item-choice.disabled {
  opacity: 0.4;
  cursor: not-allowed;
  filter: grayscale(0.7);
}
.item-choice.disabled:hover {
  transform: none;
  box-shadow: none;
}
.item-choice .emoji { font-size: 1.8rem; line-height: 1; }
.item-choice .lbl { font-size: 0.5rem; color: var(--red-dark); margin-top: 4px; font-weight: 700; text-align: center; line-height: 1; }

/* Card */
.card-section { padding: 0 16px; }
.card-head { display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px; }
.card-title { font-family: 'ZCOOL KuaiLe', cursive; font-size: 1.05rem; color: var(--gold); }
.line-badge {
  background: var(--glass); border: 1.5px solid rgba(240,192,64,0.3);
  border-radius: 20px; padding: 4px 14px; font-size: 0.78rem; color: var(--gold); font-weight: 700;
}

.bingo-card {
  background: linear-gradient(155deg, var(--cream) 0%, var(--cream-dark) 100%);
  border: 3px solid var(--gold); border-radius: 20px; padding: 10px;
  box-shadow: 0 6px 40px rgba(0,0,0,0.3), 0 0 50px rgba(240,192,64,0.08);
  position: relative;
}
.corner { position: absolute; font-size: 0.95rem; opacity: 0.18; pointer-events: none; color: var(--red); font-weight: 900; }
.corner.tl { top:7px; left:9px; } .corner.tr { top:7px; right:9px; }
.corner.bl { bottom:7px; left:9px; } .corner.br { bottom:7px; right:9px; }

.grid { display: grid; grid-template-columns: repeat(6,1fr); gap: 6px; }

.cell {
  aspect-ratio: 1; display: flex; flex-direction: column; align-items: center; justify-content: center;
  border-radius: 13px; background: rgba(255,255,255,0.55); border: 2px solid rgba(196,30,30,0.1);
  cursor: pointer; transition: all 0.15s; user-select: none; position: relative;
}
.cell:active { transform: scale(0.9); }
.cell .emoji { font-size: 1.3rem; line-height: 1.2; transition: transform 0.15s; }
.cell .lbl { font-size: 0.48rem; color: var(--red-dark); opacity: 0.6; margin-top: 1px; font-weight: 700; text-align: center; line-height: 1.1; }

.cell.marked {
  background: linear-gradient(135deg, var(--red) 0%, var(--red-dark) 100%);
  border-color: var(--gold-dim);
  box-shadow: inset 0 0 15px rgba(0,0,0,0.15);
  animation: stamp 0.25s cubic-bezier(0.175,0.885,0.32,1.275);
}
.cell.marked .emoji { filter: brightness(1.15); transform: scale(1.05); }
.cell.marked .lbl { color: var(--gold); opacity: 0.85; }
@keyframes stamp { 0%{transform:scale(1.2)} 50%{transform:scale(0.92)} 100%{transform:scale(1)} }

.cell.free { background: linear-gradient(135deg, var(--gold) 0%, var(--gold-dim) 100%); border-color: var(--red); }
.cell.free .lbl { color: var(--red-dark); opacity: 1; font-weight: 900; }

.cell.win-cell {
  animation: winGlow 0.7s ease-in-out infinite alternate;
  border-color: var(--gold-bright) !important;
  box-shadow: 0 0 18px rgba(255,215,0,0.5);
}
@keyframes winGlow { from { transform: scale(1); } to { transform: scale(1.06); filter: brightness(1.15); } }

/* Highlight cells that match the latest called item */
.cell.just-called::after {
  content: ''; position: absolute; inset: -3px;
  border: 2.5px solid var(--gold-bright);
  border-radius: 15px;
  animation: callPulse 1s ease-in-out 3;
}
@keyframes callPulse { 0%,100%{opacity:1} 50%{opacity:0.3} }

/* Overlay */
.overlay {
  display: none; position: fixed; inset: 0; z-index: 200;
  background: rgba(82,0,0,0.88); backdrop-filter: blur(10px);
  align-items: center; justify-content: center; flex-direction: column;
}
.overlay.show { display: flex; }
.overlay-emoji { font-size: 4rem; animation: bounceIn 0.6s cubic-bezier(0.175,0.885,0.32,1.275); }
.overlay-text { font-family: 'ZCOOL KuaiLe', cursive; font-size: 2.8rem; color: var(--gold); text-shadow: 0 4px 20px rgba(0,0,0,0.5); margin-top: 8px; animation: bounceIn 0.6s cubic-bezier(0.175,0.885,0.32,1.275) 0.1s both; }
.overlay-sub { font-size: 1.1rem; color: var(--cream); opacity: 0.8; margin-top: 8px; animation: fadeUp 0.5s ease-out 0.3s both; }
.overlay-btn { margin-top: 28px; padding: 14px 40px; background: var(--gold); color: var(--red-deep); border: none; border-radius: 30px; font-family: 'Noto Sans TC', sans-serif; font-size: 1rem; font-weight: 700; cursor: pointer; animation: fadeUp 0.5s ease-out 0.5s both; }
@keyframes bounceIn { 0%{transform:scale(0);opacity:0} 100%{transform:scale(1);opacity:1} }
@keyframes fadeUp { from{opacity:0;transform:translateY(10px)} to{opacity:1;transform:translateY(0)} }

/* Sparks */
.spark { position: fixed; width: 5px; height: 5px; border-radius: 50%; pointer-events: none; z-index: 201; }

/* Toast */
.toast {
  position: fixed; top: 75px; left: 50%; transform: translateX(-50%) translateY(-20px);
  background: var(--gold); color: var(--red-deep);
  padding: 10px 22px; border-radius: 30px; font-weight: 700; font-size: 0.88rem;
  z-index: 300; opacity: 0; transition: all 0.3s; pointer-events: none; white-space: nowrap;
}
.toast.show { opacity: 1; transform: translateX(-50%) translateY(0); }

/* Responsive */
@media (max-width: 400px) {
  .grid { gap: 5px; }
  .cell .emoji { font-size: 1.2rem; }
  .cell .lbl { font-size: 0.42rem; }
}
@media (min-width: 600px) {
  #gameScreen { max-width: 560px; margin: 0 auto; }
}
</style>
</head>
<body>

<div class="bg"></div>
<div class="particles" id="particles"></div>

<!-- ======== LOGIN ======== -->
<div class="screen active" id="loginScreen">
  <div class="login-card">
    <div class="login-header">ğŸ®ğŸ§§ğŸ®</div>
    <div class="login-title">ç›§æ°é›†åœ˜é¦¬ä¸Šæœ‰éŒ¢ è³“æœå¤§æ¨‚é€</div>
    <div class="login-sub">å…¨å®¶ä¸€èµ·ä¾†ï¼Œè€å°‘å’¸å®œï¼</div>

    <!-- Mode Switch -->
    <div class="mode-switch" id="modeSwitch">
      <button class="mode-btn active" onclick="switchMode('local')">ğŸ  æœ¬åœ°æ¨¡å¼</button>
      <button class="mode-btn" onclick="switchMode('online')">ğŸ“¡ ç·šä¸Šæ¨¡å¼</button>
    </div>

    <!-- Local Mode -->
    <div id="localMode">
      <div class="input-group">
        <label>ğŸ‘¥ åƒåŠ çš„äººï¼ˆç”¨é “è™Ÿåˆ†éš”ï¼‰</label>
        <input type="text" id="namesInput" placeholder="ä¾‹ï¼šçˆ¸çˆ¸ã€åª½åª½ã€é˜¿å¬¤ã€å°æ˜" autocomplete="off">
      </div>

      <div style="text-align:center; margin: 16px 0 6px;">
        <button class="login-btn" onclick="startLocalGame()">ğŸ§¨ é–‹å§‹éŠæˆ²ï¼</button>
      </div>

      <div style="font-size:0.72rem; color: var(--red-dark); opacity:0.5; text-align:center; margin-top:12px;">
        å…±äº«è¢å¹•æ¨¡å¼ï¼šå¤§å®¶åœè‘—åŒä¸€å€‹è¢å¹•ç©
      </div>
    </div>

    <!-- Online Mode -->
    <div id="onlineMode" style="display:none;">
      <!-- Create Room -->
      <div id="createRoomPanel">
        <div class="input-group">
          <label>ğŸ‘¤ ä½ çš„åå­—</label>
          <input type="text" id="hostNameInput" placeholder="ä¾‹ï¼šçˆ¸çˆ¸" autocomplete="off">
        </div>
        <div style="text-align:center; margin: 10px 0;">
          <button class="login-btn" onclick="createRoom()">ğŸŠ å»ºç«‹æˆ¿é–“</button>
          <button class="login-btn secondary" onclick="showJoinPanel()">ğŸšª åŠ å…¥æˆ¿é–“</button>
        </div>
        <div style="font-size:0.72rem; color: var(--red-dark); opacity:0.5; text-align:center; margin-top:12px;">
          ç·šä¸Šæ¨¡å¼ï¼šæ¯å€‹äººç”¨è‡ªå·±çš„æ‰‹æ©Ÿï¼Œå³æ™‚åŒæ­¥ï¼
        </div>
      </div>

      <!-- Join Room -->
      <div id="joinRoomPanel" style="display:none;">
        <div class="input-group">
          <label>ğŸ¯ æˆ¿é–“ç¢¼</label>
          <input type="text" id="roomCodeInput" placeholder="è¼¸å…¥ 4 ä½æ•¸æˆ¿é–“ç¢¼" autocomplete="off" maxlength="4" inputmode="numeric" pattern="[0-9]*">
        </div>
        <div class="input-group">
          <label>ğŸ‘¤ ä½ çš„åå­—</label>
          <input type="text" id="playerNameInput" placeholder="ä¾‹ï¼šåª½åª½" autocomplete="off">
        </div>
        <div style="text-align:center; margin: 10px 0;">
          <button class="login-btn" onclick="joinRoom()">ğŸš€ åŠ å…¥éŠæˆ²</button>
          <button class="login-btn secondary" onclick="showCreatePanel()">â† è¿”å›</button>
        </div>
      </div>

      <!-- Room Created -->
      <div id="roomCreatedPanel" style="display:none;">
        <div class="room-code-display">
          <div class="label">æˆ¿é–“ç¢¼</div>
          <div class="code" id="displayRoomCode"></div>
        </div>
        <div style="font-size:0.82rem; color: var(--red-dark); text-align:center; margin: 12px 0;">
          åˆ†äº«æˆ¿é–“ç¢¼çµ¦å…¶ä»–ç©å®¶<br>ç­‰å¾…ç©å®¶åŠ å…¥å¾Œå³å¯é–‹å§‹é–‹ç
        </div>
        <div style="text-align:center;">
          <button class="login-btn" onclick="startOnlineGame()">ğŸŠ é–‹å§‹éŠæˆ²</button>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- ======== GAME ======== -->
<div class="screen" id="gameScreen">
  <div class="top-bar">
    <div>
      <div class="top-title">ğŸ® ç›§æ°é›†åœ˜é¦¬ä¸Šæœ‰éŒ¢è³“æœ <span id="syncBadge"></span></div>
      <div class="top-info" id="topInfo"></div>
    </div>
    <div class="top-right">
      <button class="btn-sm" onclick="resetGame()">ğŸ”„ æ–°å±€</button>
      <button class="btn-sm" onclick="backToLogin()">âœ•</button>
    </div>
  </div>

  <!-- Players -->
  <div class="player-bar">
    <div class="player-bar-label">ğŸŠ ç©å®¶ï¼ˆé»é¸åˆ‡æ›æŸ¥çœ‹ï¼‰</div>
    <div class="player-tabs" id="playerTabs"></div>
  </div>

  <!-- Called Board -->
  <div class="called-section">
    <div class="called-board">
      <div class="called-board-title">ğŸ“œ é–‹çç´€éŒ„</div>
      <div class="called-list" id="calledList">
        <div class="empty-hint">æŒ‰ä¸‹é¢çš„ã€Œé–‹çã€æŠ½å‡ºéå¹´åœ–æ¡ˆå§ï¼</div>
      </div>
    </div>
  </div>

  <!-- Action -->
  <div class="action-area">
    <div class="turn-info" id="turnInfo"></div>
    <div class="item-grid" id="itemGrid"></div>
  </div>

  <!-- Bingo Card -->
  <div class="card-section">
    <div class="card-head">
      <div class="card-title" id="cardTitle">ğŸ§§ æˆ‘çš„è³“æœç‰Œ</div>
      <div class="line-badge" id="lineBadge">é€£ç·šï¼š0</div>
    </div>
    <div class="bingo-card">
      <span class="corner tl">ç¦</span>
      <span class="corner tr">æ˜¥</span>
      <span class="corner bl">è²¡</span>
      <span class="corner br">æ—º</span>
      <div class="grid" id="grid"></div>
    </div>
  </div>
</div>

<!-- Win -->
<div class="overlay" id="winOverlay">
  <div class="overlay-emoji">ğŸ†ğŸ§§ğŸ†</div>
  <div class="overlay-text">è³“æœï¼</div>
  <div class="overlay-sub" id="winSub"></div>
  <button class="overlay-btn" onclick="closeOverlay()">ğŸŠ ç¹¼çºŒç©</button>
</div>

<div class="toast" id="toast"></div>

<script>
// =========================================================
// FIREBASE CONFIG
// =========================================================
// ğŸ”¥ Firebase é…ç½®
// è©³ç´°è¨­å®šæ­¥é©Ÿè«‹åƒè€ƒ FIREBASE_SETUP.md
const firebaseConfig = {
  apiKey: "AIzaSyCbAlw-_oXbZ1XRujDfrvXGUfNBsVmzONk",
  authDomain: "cny-bingo.firebaseapp.com",
  databaseURL: "https://cny-bingo-default-rtdb.asia-southeast1.firebasedatabase.app",
  projectId: "cny-bingo",
  storageBucket: "cny-bingo.firebasestorage.app",
  messagingSenderId: "483196851206",
  appId: "1:483196851206:web:891fad23ced5450c939f87"
};

let firebaseEnabled = false;
let db = null;
let currentRoomRef = null;
let currentRoomCode = null;
let isHost = false;
let gameMode = 'local'; // 'local' or 'online'
let myPlayerName = ''; // Current player's name
let currentTurn = ''; // Whose turn it is
let turnOrder = []; // Array of player names in turn order

// Initialize Firebase if config is valid
try {
  if (firebaseConfig.apiKey !== "YOUR_API_KEY" && firebaseConfig.databaseURL !== "YOUR_DATABASE_URL") {
    firebase.initializeApp(firebaseConfig);
    db = firebase.database();
    firebaseEnabled = true;
    console.log('ğŸ”¥ Firebase å·²å•Ÿç”¨');
  } else {
    console.log('â„¹ï¸ Firebase æœªè¨­å®šï¼Œä½¿ç”¨æœ¬åœ°æ¨¡å¼');
  }
} catch (e) {
  console.log('â„¹ï¸ Firebase åˆå§‹åŒ–å¤±æ•—ï¼Œä½¿ç”¨æœ¬åœ°æ¨¡å¼', e);
}

// =========================================================
// ITEMS
// =========================================================
const ALL_ITEMS = [
  {e:'ğŸ§§',l:'ç´…åŒ…'},{e:'ğŸ®',l:'ç‡ˆç± '},{e:'ğŸ§¨',l:'é­ç‚®'},{e:'ğŸ‰',l:'é¾'},
  {e:'ğŸ',l:'è›‡'},{e:'ğŸ‹',l:'ç«¹å ±å¹³å®‰'},{e:'ğŸŠ',l:'å½©å¸¶'},{e:'ğŸ†',l:'ç…™ç«'},
  {e:'ğŸŠ',l:'æ©˜å­'},{e:'ğŸ ',l:'å›å®¶'},{e:'ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦',l:'åœ˜åœ“'},{e:'ğŸ¥Ÿ',l:'æ°´é¤ƒ'},
  {e:'ğŸŸ',l:'å¹´å¹´æœ‰é¤˜'},{e:'ğŸš',l:'å¹´ç³•'},{e:'ğŸ¦',l:'èˆç…'},{e:'ğŸ¶',l:'æ­å–œæ­å–œ'},
  {e:'ğŸ’°',l:'ç™¼è²¡'},{e:'ğŸ',l:'æ‹œå¹´'},{e:'ğŸŒ¸',l:'æ¢…èŠ±'},{e:'ğŸ´',l:'æ˜¥è¯'},
  {e:'ğŸ¡',l:'æ¹¯åœ“'},{e:'ğŸ”',l:'å¤§å‰'},{e:'ğŸ¯',l:'å¥½å½©é ­'},{e:'â›©ï¸',l:'å»Ÿå®‡'},
  {e:'ğŸª™',l:'é‡‘å¹£'},{e:'ğŸ',l:'æ——å¹Ÿ'},{e:'ğŸ‘',l:'å£½æ¡ƒ'},{e:'ğŸ¢',l:'é•·å£½'},
  {e:'ğŸŒ•',l:'æœˆåœ“'},{e:'âœ¨',l:'å‰ç¥¥'},{e:'ğŸ«•',l:'ç«é‹'},{e:'ğŸ°',l:'å¥½é‹'},
  {e:'ğŸª­',l:'æ‰‡å­'},{e:'ğŸ²',l:'é¾èˆŸ'},{e:'ğŸ',l:'ç¦®ç‰©'},
];

const FREE = {e:'ğŸ§§',l:'ç¦',free:true};

// =========================================================
// STATE
// =========================================================
let players = []; // [{name, card:[{e,l,free?,marked,winLine}], lines}]
let calledItems = []; // [{e,l,round}]
let currentView = 0; // which player tab is active
let winShownFor = new Set();
let fromLobby = false;
let lobbyParams = null;
let turnTimer = null;
let turnTimeLeft = 0;
const TURN_TIME_LIMIT = 30; // seconds per turn

// =========================================================
// SEEDED SHUFFLE
// =========================================================
function seededShuffle(arr, seed) {
  let h = 0;
  for (let i = 0; i < seed.length; i++) h = ((h << 5) - h + seed.charCodeAt(i)) | 0;
  const rng = () => { h = (h * 16807) % 2147483647; return (h & 0x7FFFFFFF) / 0x7FFFFFFF; };
  const a = [...arr];
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(rng() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

function makeCard(name) {
  const shuffled = seededShuffle(ALL_ITEMS, name + ':cny2026:bingo');
  // For 6x6 grid: use all 35 items + 1 free space = 36 cells
  const picked = shuffled.map(it => ({e:it.e, l:it.l, marked:false, winLine:false}));
  // Insert FREE space at position 17 (middle-ish of 6x6 grid)
  picked.splice(17, 0, {e:FREE.e, l:FREE.l, free:true, marked:true, winLine:false});
  return picked;
}

// =========================================================
// MODE SWITCHING
// =========================================================
function switchMode(mode) {
  gameMode = mode;
  const buttons = document.querySelectorAll('.mode-btn');
  buttons.forEach(btn => btn.classList.remove('active'));
  event.target.classList.add('active');

  if (mode === 'local') {
    document.getElementById('localMode').style.display = 'block';
    document.getElementById('onlineMode').style.display = 'none';
  } else {
    if (!firebaseEnabled) {
      showToast('è«‹å…ˆè¨­å®š Firebaseï¼ˆåƒè€ƒ FIREBASE_SETUP.mdï¼‰');
      setTimeout(() => switchMode('local'), 100);
      return;
    }
    document.getElementById('localMode').style.display = 'none';
    document.getElementById('onlineMode').style.display = 'block';
  }
}

function showJoinPanel() {
  document.getElementById('createRoomPanel').style.display = 'none';
  document.getElementById('joinRoomPanel').style.display = 'block';
}

function showCreatePanel() {
  document.getElementById('joinRoomPanel').style.display = 'none';
  document.getElementById('createRoomPanel').style.display = 'block';
}

// =========================================================
// ROOM MANAGEMENT
// =========================================================
function generateRoomCode() {
  return String(Math.floor(1000 + Math.random() * 9000));
}

async function createRoom() {
  const hostName = document.getElementById('hostNameInput').value.trim();
  if (!hostName) {
    showToast('è«‹è¼¸å…¥ä½ çš„åå­—');
    return;
  }

  currentRoomCode = generateRoomCode();
  currentRoomRef = db.ref('rooms/' + currentRoomCode);
  isHost = true;
  myPlayerName = hostName;

  // Create room data
  await currentRoomRef.set({
    host: hostName,
    players: { [hostName]: { name: hostName, joinedAt: Date.now(), lines: 0 } },
    calledItems: [],
    turnOrder: [hostName],
    currentTurn: hostName,
    resetCounter: 0,
    createdAt: Date.now(),
    gameStarted: false
  });

  // Setup player
  players = [{
    name: hostName,
    card: makeCard(hostName),
    lines: 0
  }];

  currentTurn = hostName;
  turnOrder = [hostName];

  // Show room code
  document.getElementById('displayRoomCode').textContent = currentRoomCode;
  document.getElementById('createRoomPanel').style.display = 'none';
  document.getElementById('roomCreatedPanel').style.display = 'block';

  // Listen for new players
  listenToRoom();

  showToast('æˆ¿é–“å·²å»ºç«‹ï¼');
}

async function joinRoom() {
  const roomCode = document.getElementById('roomCodeInput').value.trim().toUpperCase();
  const playerName = document.getElementById('playerNameInput').value.trim();

  if (!roomCode || roomCode.length !== 4) {
    showToast('è«‹è¼¸å…¥ 4 ä½æ•¸æˆ¿é–“ç¢¼');
    return;
  }

  if (!playerName) {
    showToast('è«‹è¼¸å…¥ä½ çš„åå­—');
    return;
  }

  currentRoomCode = roomCode;
  currentRoomRef = db.ref('rooms/' + currentRoomCode);
  isHost = false;
  myPlayerName = playerName;

  // Check if room exists
  const snapshot = await currentRoomRef.once('value');
  if (!snapshot.exists()) {
    showToast('æˆ¿é–“ä¸å­˜åœ¨');
    return;
  }

  const roomData = snapshot.val();

  // Check if name already taken
  if (roomData.players && roomData.players[playerName]) {
    showToast('åå­—å·²è¢«ä½¿ç”¨');
    return;
  }

  // Add player to room
  await currentRoomRef.child('players').child(playerName).set({
    name: playerName,
    joinedAt: Date.now(),
    lines: 0
  });

  // Update turn order
  const newTurnOrder = [...(roomData.turnOrder || []), playerName];
  await currentRoomRef.child('turnOrder').set(newTurnOrder);

  // Setup local player
  players = [{
    name: playerName,
    card: makeCard(playerName),
    lines: 0
  }];

  currentView = 0;

  // Listen to room updates
  listenToRoom();

  // Start game
  startOnlineGame();
}

function listenToRoom() {
  if (!currentRoomRef) return;

  // Listen for resetCounter
  currentRoomRef.child('resetCounter').on('value', (snapshot) => {
    const counter = snapshot.val() || 0;
    if (counter > 0) {
      // Reset only my card
      players.forEach(p => {
        if (p.name === myPlayerName) {
          p.card = makeCard(p.name);
        }
        p.lines = 0;
      });
      winShownFor = new Set();
      if (document.getElementById('gameScreen').classList.contains('active')) {
        render();
      }
    }
  });

  // Listen for currentTurn
  currentRoomRef.child('currentTurn').on('value', (snapshot) => {
    currentTurn = snapshot.val() || '';
    if (document.getElementById('gameScreen').classList.contains('active')) {
      startTurnTimer();
      render();
    }
  });

  // Listen for turnOrder
  currentRoomRef.child('turnOrder').on('value', (snapshot) => {
    turnOrder = snapshot.val() || [];
    if (document.getElementById('gameScreen').classList.contains('active')) {
      render();
    }
  });

  // Listen for players
  currentRoomRef.child('players').on('value', (snapshot) => {
    const playersData = snapshot.val() || {};
    const playerNames = Object.keys(playersData);

    // Find my current card to preserve it
    const myCurrentPlayer = players.find(p => p.name === myPlayerName);
    const myCurrentCard = myCurrentPlayer ? myCurrentPlayer.card : null;

    // Update players array: keep my card, but update all players' info
    players = playerNames.map(name => {
      const fbData = playersData[name];

      if (name === myPlayerName) {
        // For myself: ALWAYS keep my current card (preserve marked state)
        return {
          name,
          card: myCurrentCard || makeCard(name),
          lines: fbData.lines || 0
        };
      } else {
        // For others: just store name and lines (no card needed)
        return {
          name,
          card: [], // Empty card for other players
          lines: fbData.lines || 0
        };
      }
    });

    if (document.getElementById('gameScreen').classList.contains('active')) {
      render();
    }
  });

  // Listen for called items
  currentRoomRef.child('calledItems').on('value', async (snapshot) => {
    const items = snapshot.val() || [];
    if (items.length > calledItems.length || JSON.stringify(items) !== JSON.stringify(calledItems)) {
      calledItems = items;

      // Auto-mark ONLY my card
      const myPlayer = players.find(p => p.name === myPlayerName);
      if (myPlayer && myPlayer.card && myPlayer.card.length > 0) {
        myPlayer.card.forEach(cell => {
          if (cell.free) return;
          const wasCalled = calledItems.some(c => c.e === cell.e && c.l === cell.l);
          if (wasCalled) cell.marked = true;
        });

        // Recompute my lines
        const lines = getWinLines(myPlayer.card);
        myPlayer.lines = lines.length;
        myPlayer.card.forEach(c => c.winLine = false);
        lines.forEach(line => line.forEach(i => myPlayer.card[i].winLine = true));

        // Update my lines count to Firebase
        await currentRoomRef.child('players').child(myPlayerName).update({
          lines: myPlayer.lines
        });

        render();

        // Check for my bingo
        if (myPlayer.lines >= 5 && !winShownFor.has(myPlayerName)) {
          winShownFor.add(myPlayerName);
          showWin(myPlayer.name);
        }
      }
    }
  });
}

function startOnlineGame() {
  calledItems = [];
  winShownFor = new Set();

  document.getElementById('loginScreen').classList.remove('active');
  document.getElementById('gameScreen').classList.add('active');

  const syncBadge = document.getElementById('syncBadge');
  syncBadge.innerHTML = `<span class="sync-badge">ğŸ“¡ æˆ¿é–“ ${currentRoomCode}</span>`;

  document.getElementById('topInfo').textContent = `${players.length} ä½ç©å®¶`;

  render();
}

// =========================================================
// START GAME
// =========================================================
function startLocalGame() {
  const raw = document.getElementById('namesInput').value.trim();
  if (!raw) { showToast('è«‹è¼¸å…¥è‡³å°‘ä¸€å€‹åå­—'); return; }

  const names = raw.split(/[ã€,ï¼Œ\s]+/).map(s => s.trim()).filter(Boolean);
  if (names.length === 0) { showToast('è«‹è¼¸å…¥è‡³å°‘ä¸€å€‹åå­—'); return; }
  if (new Set(names).size < names.length) { showToast('æœ‰é‡è¤‡çš„åå­—å–”ï¼'); return; }

  players = names.map(name => ({
    name,
    card: makeCard(name),
    lines: 0
  }));

  calledItems = [];
  winShownFor = new Set();
  currentView = 0;

  document.getElementById('loginScreen').classList.remove('active');
  document.getElementById('gameScreen').classList.add('active');
  document.getElementById('topInfo').textContent = `${players.length} ä½ç©å®¶`;

  render();
}

function backToLogin() {
  // Cleanup Firebase listeners
  if (currentRoomRef) {
    currentRoomRef.off();
    if (isHost) {
      currentRoomRef.remove(); // Delete room if host
    }
  }

  stopTurnTimer();

  // Reset state
  currentRoomRef = null;
  currentRoomCode = null;
  isHost = false;
  players = [];
  calledItems = [];
  winShownFor = new Set();

  // If launched from lobby, navigate back to lobby
  if (fromLobby && lobbyParams) {
    const params = new URLSearchParams({
      lobby: lobbyParams.lobby,
      name: lobbyParams.name,
      host: lobbyParams.host ? '1' : '0'
    });
    window.location.href = 'index.html?' + params.toString();
    return;
  }

  document.getElementById('gameScreen').classList.remove('active');
  document.getElementById('loginScreen').classList.add('active');
  document.getElementById('syncBadge').innerHTML = '';

  // Reset panels
  document.getElementById('createRoomPanel').style.display = 'block';
  document.getElementById('joinRoomPanel').style.display = 'none';
  document.getElementById('roomCreatedPanel').style.display = 'none';
}

async function resetGame() {
  stopTurnTimer();
  calledItems = [];
  winShownFor = new Set();

  if (gameMode === 'online' && currentRoomRef) {
    if (!isHost) {
      showToast('åªæœ‰ä¸»æŒäººå¯ä»¥é‡è¨­éŠæˆ²');
      return;
    }
    // Reset Firebase
    const snapshot = await currentRoomRef.child('resetCounter').once('value');
    const newCounter = (snapshot.val() || 0) + 1;

    // Reset all players' lines to 0
    const playersSnapshot = await currentRoomRef.child('players').once('value');
    const playersData = playersSnapshot.val() || {};
    const updates = {};
    Object.keys(playersData).forEach(name => {
      updates[`players/${name}/lines`] = 0;
    });

    await currentRoomRef.update({
      calledItems: [],
      resetCounter: newCounter,
      currentTurn: turnOrder[0] || '',
      ...updates
    });
  }

  players.forEach(p => {
    p.card = makeCard(p.name);
    p.lines = 0;
  });
  render();
  showToast('æ–°çš„ä¸€å±€é–‹å§‹ï¼');
}

// =========================================================
// CALL NEXT
// =========================================================
// Select a specific item (for turn-based gameplay)
async function selectItem(item) {
  if (calledItems.length >= ALL_ITEMS.length) {
    showToast('æ‰€æœ‰é …ç›®éƒ½é–‹å®Œäº†ï¼');
    return;
  }

  // Check if it's this player's turn in online mode
  if (gameMode === 'online') {
    if (currentTurn !== myPlayerName) {
      showToast('é‚„æ²’è¼ªåˆ°ä½ ï¼');
      return;
    }
  }

  // Check if already called
  const calledSet = new Set(calledItems.map(c => c.e + c.l));
  if (calledSet.has(item.e + item.l)) {
    showToast('é€™å€‹åœ–æ¡ˆå·²ç¶“è¢«é¸éäº†ï¼');
    return;
  }

  const newItem = { e: item.e, l: item.l, round: calledItems.length + 1 };

  // Update Firebase or local
  if (gameMode === 'online' && currentRoomRef) {
    const updatedItems = [...calledItems, newItem];

    // Calculate next turn
    const currentIndex = turnOrder.indexOf(currentTurn);
    const nextIndex = (currentIndex + 1) % turnOrder.length;
    const nextTurn = turnOrder[nextIndex];

    await currentRoomRef.update({
      calledItems: updatedItems,
      currentTurn: nextTurn
    });
    // Firebase listener will update local state
  } else {
    // Local mode
    calledItems.push(newItem);

    // Auto-mark on all players
    players.forEach(p => {
      p.card.forEach(cell => {
        if (!cell.free && cell.e === item.e && cell.l === item.l) {
          cell.marked = true;
        }
      });
    });

    // Check lines for all
    players.forEach(p => {
      const lines = getWinLines(p.card);
      p.lines = lines.length;
      p.card.forEach(c => c.winLine = false);
      lines.forEach(line => line.forEach(i => p.card[i].winLine = true));
    });

    render();

    // Check for new bingos
    players.forEach((p, i) => {
      if (p.lines >= 5 && !winShownFor.has(i)) {
        winShownFor.add(i);
        showWin(p.name);
      }
    });
  }
}

// =========================================================
// WIN LINES
// =========================================================
function getWinLines(card) {
  const lines = [];
  // Check rows (6x6 grid)
  for (let r = 0; r < 6; r++) {
    const row = [r*6, r*6+1, r*6+2, r*6+3, r*6+4, r*6+5];
    if (row.every(i => card[i].marked)) lines.push(row);
  }
  // Check columns
  for (let c = 0; c < 6; c++) {
    const col = [c, c+6, c+12, c+18, c+24, c+30];
    if (col.every(i => card[i].marked)) lines.push(col);
  }
  // Check diagonal (top-left to bottom-right)
  if ([0, 7, 14, 21, 28, 35].every(i => card[i].marked)) {
    lines.push([0, 7, 14, 21, 28, 35]);
  }
  // Check diagonal (top-right to bottom-left)
  if ([5, 10, 15, 20, 25, 30].every(i => card[i].marked)) {
    lines.push([5, 10, 15, 20, 25, 30]);
  }
  return lines;
}

// =========================================================
// RENDER
// =========================================================
function render() {
  renderPlayerTabs();
  renderCalledList();
  renderItemGrid();
  renderTurnInfo();
  renderCard();
}

function renderPlayerTabs() {
  const el = document.getElementById('playerTabs');

  if (gameMode === 'online') {
    // Online mode: show all players with their lines count
    el.innerHTML = players.map((p, i) => {
      const isMe = p.name === myPlayerName;
      const active = isMe ? 'active' : '';
      const lineInfo = p.lines > 0 ? ` (${p.lines}ç·š)` : '';
      const bingo = p.lines >= 5 ? `<span class="bingo-flag">BINGO!</span>` : '';
      return `<button class="ptab ${active}">
        <span class="dot"></span>${p.name}${lineInfo}${bingo}
      </button>`;
    }).join('');
  } else {
    // Local mode: show all players with switching
    el.innerHTML = players.map((p, i) => {
      const active = i === currentView ? 'active' : '';
      const bingo = p.lines >= 5 ? `<span class="bingo-flag">BINGO ${p.lines}ç·š</span>` : '';
      return `<button class="ptab ${active}" onclick="switchView(${i})">
        <span class="dot"></span>${p.name}${bingo}
      </button>`;
    }).join('');
  }
}

function switchView(idx) {
  currentView = idx;
  render();
}

function renderCalledList() {
  const el = document.getElementById('calledList');
  if (calledItems.length === 0) {
    el.innerHTML = `<div class="empty-hint">æŒ‰ä¸‹é¢çš„ã€Œé–‹çã€æŠ½å‡ºéå¹´åœ–æ¡ˆå§ï¼</div>`;
    return;
  }
  el.innerHTML = calledItems.slice().reverse().map((c, i) => {
    const cls = i === 0 ? 'called-row latest' : 'called-row';
    return `<div class="${cls}">
      <span class="c-round">#${c.round}</span>
      <span class="c-icon">${c.e}</span>
      <span class="c-name">${c.l}</span>
    </div>`;
  }).join('');
}

function renderCard() {
  // In online mode, always show my card; in local mode, show current view
  const viewIndex = gameMode === 'online'
    ? players.findIndex(p => p.name === myPlayerName)
    : currentView;

  if (viewIndex === -1) return; // Player not found

  const p = players[viewIndex];
  document.getElementById('cardTitle').textContent = `ğŸ§§ ${p.name} çš„è³“æœç‰Œ`;
  document.getElementById('lineBadge').textContent = `é€£ç·šï¼š${p.lines}`;

  const lastCalled = calledItems.length > 0 ? calledItems[calledItems.length - 1] : null;
  const grid = document.getElementById('grid');
  grid.innerHTML = '';

  p.card.forEach((cell, i) => {
    const div = document.createElement('div');
    let cls = 'cell';
    if (cell.marked) cls += ' marked';
    if (cell.free) cls += ' free';
    if (cell.winLine) cls += ' win-cell';
    // Highlight if this cell matches the latest call
    if (lastCalled && !cell.free && cell.e === lastCalled.e && cell.l === lastCalled.l && cell.marked) {
      cls += ' just-called';
    }
    div.className = cls;
    div.innerHTML = `<span class="emoji">${cell.e}</span><span class="lbl">${cell.l}</span>`;

    // In online mode, disable manual marking (auto-sync only)
    // In local mode, allow manual marking
    if (!cell.free && gameMode === 'local') {
      div.onclick = () => {
        cell.marked = !cell.marked;
        // Recompute lines
        const lines = getWinLines(p.card);
        p.lines = lines.length;
        p.card.forEach(c => c.winLine = false);
        lines.forEach(line => line.forEach(j => p.card[j].winLine = true));
        render();
        if (p.lines >= 5 && !winShownFor.has(viewIndex)) {
          winShownFor.add(viewIndex);
          showWin(p.name);
        }
      };
    }
    grid.appendChild(div);
  });
}

function renderTurnInfo() {
  const info = document.getElementById('turnInfo');

  if (calledItems.length >= ALL_ITEMS.length) {
    info.innerHTML = 'ğŸŠ å…¨éƒ¨é–‹å®Œäº†ï¼';
    info.className = 'turn-info';
    stopTurnTimer();
  } else {
    if (gameMode === 'online') {
      const isMyTurn = currentTurn === myPlayerName;
      const timerHtml = turnTimeLeft > 0
        ? `<span class="turn-timer${turnTimeLeft <= 10 ? ' warning' : ''}">${turnTimeLeft}</span>`
        : '';
      const text = isMyTurn
        ? `ğŸ¯ è¼ªåˆ°ä½ é¸ç‰Œäº†ï¼ï¼ˆ${calledItems.length + 1}/${ALL_ITEMS.length}ï¼‰`
        : `â³ ç­‰å¾… ${currentTurn} é¸ç‰Œ...ï¼ˆ${calledItems.length + 1}/${ALL_ITEMS.length}ï¼‰`;
      info.innerHTML = `<span>${text}</span>${timerHtml}`;
      info.className = isMyTurn ? 'turn-info my-turn' : 'turn-info';
    } else {
      info.innerHTML = `ğŸŠ é¸æ“‡åœ–æ¡ˆï¼ˆ${calledItems.length + 1}/${ALL_ITEMS.length}ï¼‰`;
      info.className = 'turn-info';
    }
  }
}

// =========================================================
// TURN TIMER (online mode)
// =========================================================
function startTurnTimer() {
  stopTurnTimer();
  if (gameMode !== 'online') return;
  if (calledItems.length >= ALL_ITEMS.length) return;

  turnTimeLeft = TURN_TIME_LIMIT;
  renderTurnInfo();

  turnTimer = setInterval(() => {
    turnTimeLeft--;
    renderTurnInfo();

    if (turnTimeLeft <= 0) {
      stopTurnTimer();
      // Only the current turn player auto-selects
      if (currentTurn === myPlayerName) {
        autoSelectItem();
      }
    }
  }, 1000);
}

function stopTurnTimer() {
  if (turnTimer) {
    clearInterval(turnTimer);
    turnTimer = null;
  }
  turnTimeLeft = 0;
}

function autoSelectItem() {
  const calledSet = new Set(calledItems.map(c => c.e + c.l));
  const remaining = ALL_ITEMS.filter(item => !calledSet.has(item.e + item.l));
  if (remaining.length === 0) return;

  const randomItem = remaining[Math.floor(Math.random() * remaining.length)];
  showToast('â° æ™‚é–“åˆ°ï¼è‡ªå‹•é¸ç‰Œ');
  selectItem(randomItem);
}

function renderItemGrid() {
  const grid = document.getElementById('itemGrid');
  if (!grid) return;

  const calledSet = new Set(calledItems.map(c => c.e + c.l));
  const canSelect = gameMode === 'local' || (gameMode === 'online' && currentTurn === myPlayerName);

  grid.innerHTML = ALL_ITEMS.map(item => {
    const isCalled = calledSet.has(item.e + item.l);
    const disabled = isCalled || !canSelect;
    const cls = disabled ? 'item-choice disabled' : 'item-choice';

    return `<div class="${cls}" onclick="${disabled ? '' : `selectItem({e:'${item.e}',l:'${item.l}'})`}">
      <span class="emoji">${item.e}</span>
      <span class="lbl">${item.l}</span>
    </div>`;
  }).join('');
}

// =========================================================
// WIN
// =========================================================
function showWin(name) {
  document.getElementById('winOverlay').classList.add('show');
  document.getElementById('winSub').textContent = `${name} æ­å–œç™¼è²¡ï¼ğŸ§§`;
  launchFireworks();
}
function closeOverlay() { document.getElementById('winOverlay').classList.remove('show'); }

function launchFireworks() {
  const colors = ['#FFD700','#FF5F52','#FFF176','#FF6F00','#4CAF50','#E91E63'];
  for (let b = 0; b < 6; b++) {
    setTimeout(() => {
      const cx = Math.random() * window.innerWidth;
      const cy = Math.random() * window.innerHeight * 0.5;
      for (let i = 0; i < 24; i++) {
        const s = document.createElement('div');
        s.className = 'spark';
        s.style.left = cx+'px'; s.style.top = cy+'px';
        s.style.background = colors[Math.floor(Math.random()*colors.length)];
        const a = (Math.PI*2/24)*i, d = 50+Math.random()*100;
        s.style.transition = `all ${0.5+Math.random()*0.5}s ease-out`;
        document.body.appendChild(s);
        requestAnimationFrame(() => { s.style.transform = `translate(${Math.cos(a)*d}px,${Math.sin(a)*d}px)`; s.style.opacity = '0'; });
        setTimeout(() => s.remove(), 1500);
      }
    }, b * 250);
  }
}

// =========================================================
// TOAST
// =========================================================
function showToast(msg) {
  const t = document.getElementById('toast');
  t.textContent = msg;
  t.classList.add('show');
  setTimeout(() => t.classList.remove('show'), 2500);
}

// =========================================================
// PARTICLES
// =========================================================
(function() {
  const c = document.getElementById('particles');
  const icons = ['ğŸ®','ğŸ§§','âœ¨','ğŸ’«','ğŸŒ¸','ğŸŠ'];
  for (let i = 0; i < 10; i++) {
    const el = document.createElement('div');
    el.className = 'particle';
    el.textContent = icons[Math.floor(Math.random()*icons.length)];
    el.style.left = Math.random()*100+'%';
    el.style.fontSize = (1+Math.random()*1.5)+'rem';
    el.style.animationDuration = (18+Math.random()*20)+'s';
    el.style.animationDelay = (-Math.random()*35)+'s';
    c.appendChild(el);
  }
})();

// =========================================================
// LOBBY INTEGRATION
// =========================================================
async function initFromLobby(code, name, host) {
  gameMode = 'online';
  myPlayerName = name;
  isHost = host;
  currentRoomCode = code;
  currentRoomRef = db.ref('rooms/' + code);

  if (host) {
    // Host creates the bingo room
    await currentRoomRef.set({
      host: name,
      players: { [name]: { name, joinedAt: Date.now(), lines: 0 } },
      calledItems: [],
      turnOrder: [name],
      currentTurn: name,
      resetCounter: 0,
      createdAt: Date.now(),
      gameStarted: true
    });

    players = [{ name, card: makeCard(name), lines: 0 }];
    currentTurn = name;
    turnOrder = [name];
  } else {
    // Non-host waits for room to exist, then joins
    let attempts = 0;
    let roomData = null;
    while (attempts < 20) {
      const snapshot = await currentRoomRef.once('value');
      if (snapshot.exists()) {
        roomData = snapshot.val();
        break;
      }
      await new Promise(r => setTimeout(r, 500));
      attempts++;
    }

    if (!roomData) {
      showToast('ç„¡æ³•åŠ å…¥éŠæˆ²æˆ¿é–“');
      if (lobbyParams) {
        const params = new URLSearchParams({
          lobby: lobbyParams.lobby,
          name: lobbyParams.name,
          host: '0'
        });
        window.location.href = 'index.html?' + params.toString();
      }
      return;
    }

    // Add player to room
    await currentRoomRef.child('players').child(name).set({
      name, joinedAt: Date.now(), lines: 0
    });

    // Update turn order
    const newTurnOrder = [...(roomData.turnOrder || []), name];
    await currentRoomRef.child('turnOrder').set(newTurnOrder);

    players = [{ name, card: makeCard(name), lines: 0 }];
    currentView = 0;
  }

  listenToRoom();
  startOnlineGame();
}

// Check for lobby URL params on load
(function checkLobbyParams() {
  const params = new URLSearchParams(window.location.search);
  const lobby = params.get('lobby');
  const name = params.get('name');
  const host = params.get('host');

  if (lobby && name && firebaseEnabled) {
    fromLobby = true;
    lobbyParams = { lobby, name, host: host === '1' };
    // Clean URL
    window.history.replaceState({}, '', window.location.pathname);
    initFromLobby(lobby, name, host === '1');
  }
})();

// Enter to start
document.addEventListener('keydown', e => {
  if (e.key === 'Enter' && document.getElementById('loginScreen').classList.contains('active')) startLocalGame();
});
</script>

</body>
</html>
